1.2 手続きとその生成プロセス
----

* 優れたプログラマになるには、検討中のプロセスを視覚化することを学ばなくてはならない


1.2.1 線形再帰と反復
----

### 再帰的プロセス (recursive process)

* 置き換えモデルで、膨張と収縮の形をとる
* 膨張は、 *遅延演算* (deferred operations) の列を作るとき
* 収縮は、演算が実際に実行されるとき
* 解釈系は、遅延演算の列を記憶しておく必要がある
* 線形再帰的プロセス (linear recursive process)
    * 遅延演算の列が線形に成長するプロセス

### 反復的プロセス (iterative process)

* 置き換えモデルで、伸縮しない
* 構成
    * *状態変数* (state variables)
    * 状態変数の更新方法
    * 停止条件
* 線形反復的プロセス (linear iterative process)
    * ステップ数が線形に成長するプロセス
* 末尾再帰的 (tail recursive)
    * 固定スペースで実行できる

### プロセス (process) と手続き (procedure)

* 手続きは、構文上の事実
    * 反復的プロセスは、再帰的手続きで実装されるが、再帰的プロセスではない


1.3.4 値として返される手続き
----

* 手続きを受け取り手続きを返す手続きを作ると、さらなる表現力を得られる
    * `procedure :: (a -> b) -> (c -> d)`
* 抽象を用いて手続きを表すと、考え方が明瞭になる
* Newton 法
    * `x -> g(x)` が微分可能
    * `f(x) = dg(x)/dx`
    * `Dg(x)` は、 `x -> f(x)` の不動点
    * Newton 法は、不動点プロセスで表される
* 抽象と第一手続き
    * プログラムから抽象を見つけ、より一般的な抽象を構成するよう努めなければならい
    * 抽象のレベルは、時と場合によって適切選ぶ
    * 抽象を使って考えると、異なる状況にも応用できる
    * 高階手続きは、抽象を他の計算要素のように扱うことができるという点で、重要である
    * 第一級 (first-class)
        * 変数として命名できる
        * 手続きが引数としてとれる
        * 手続きの返り値になれる
        * データ構造に組み込むことができる
