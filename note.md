1.2 手続きとその生成プロセス
----

* 優れたプログラマになるには、検討中のプロセスを視覚化することを学ばなくてはならない


1.2.1 線形再帰と反復
----

### 再帰的プロセス (recursive process)

* 置き換えモデルで、膨張と収縮の形をとる
* 膨張は、 *遅延演算* (deferred operations) の列を作るとき
* 収縮は、演算が実際に実行されるとき
* 解釈系は、遅延演算の列を記憶しておく必要がある
* 線形再帰的プロセス (linear recursive process)
    * 遅延演算の列が線形に成長するプロセス

### 反復的プロセス (iterative process)

* 置き換えモデルで、伸縮しない
* 構成
    * *状態変数* (state variables)
    * 状態変数の更新方法
    * 停止条件
* 線形反復的プロセス (linear iterative process)
    * ステップ数が線形に成長するプロセス
* 末尾再帰的 (tail recursive)
    * 固定スペースで実行できる

### プロセス (process) と手続き (procedure)

* 手続きは、構文上の事実
    * 反復的プロセスは、再帰的手続きで実装されるが、再帰的プロセスではない


1.2.2 木構造再帰 (tree recursion)
----

* 木構造再帰は、階層構造のデータを扱うとき、反復的アルゴリズムより直感的
* ただし、計算量は反復的アルゴリズムくらべて、はるかに多い
* テーブル化 (tabulation) やメモ化 (memoization) 冗長な計算を回避できる


1.2.3 増加の程度 (order of growth)
----

* 計算資源の消費速度は、プロセスによって大いに違う
* *増加の程度* (order of growth) で、見積もる
* `Θ(f(n))`
    * `n` 問題の大きさを表すパラメタ
    * `R(n)` `n` に対して、プロセスが必要とする基本機械演算数
    * `k1 * f(n) <= R(n) <= k2 * f(n)` を満たす独立な正の定数 `k1`, `k2` が存在する

1.3.4 値として返される手続き
----

* 手続きを受け取り手続きを返す手続きを作ると、さらなる表現力を得られる
    * `procedure :: (a -> b) -> (c -> d)`
* 抽象を用いて手続きを表すと、考え方が明瞭になる
* Newton 法
    * `x -> g(x)` が微分可能
    * `f(x) = dg(x)/dx`
    * `Dg(x)` は、 `x -> f(x)` の不動点
    * Newton 法は、不動点プロセスで表される
* 抽象と第一手続き
    * プログラムから抽象を見つけ、より一般的な抽象を構成するよう努めなければならい
    * 抽象のレベルは、時と場合によって適切選ぶ
    * 抽象を使って考えると、異なる状況にも応用できる
    * 高階手続きは、抽象を他の計算要素のように扱うことができるという点で、重要である
    * 第一級 (first-class)
        * 変数として命名できる
        * 手続きが引数としてとれる
        * 手続きの返り値になれる
        * データ構造に組み込むことができる
